<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //배열의 메서드
        //[1] 객체
        //배열 --> 일반적으로는 같은 타입의 데이터를 묶어서 사용 ==> 동적타입언어에서는 타입에 관계없이 사용함
        //객체는 특성(특징)둘울 묶어서 줄 수 있고(속성), 해당 객체의 동작(메서드)도 정의해서 묶어 줄 수 있다.

        const ar = [];
        ar.push('국어');
        ar.push('영어');
        ar.push('수학');

        console.log(ar) //['국어','영어','수학']

        const arr = [1,2,3,4,5,6]
        console.log(arr) //[1,2,3,4,5,6]

        //처음값과 끝값
        const animals = [ 'tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo' ];

        console.log(animals[0]) //처음값 //tiger
        console.log(animals[4]) //cat
        console.log(animals.length) //7
        console.log(animals[animals.length - 1]) //맨 끝값을 구하는 방법

        //undefined 값을 가지는 경우
        let blue; //undefined
        
        
        function 함수(){

        }
        console.log(함수()) //undefined



        console.log(animals[5]); //sheep
        console.log(animals[10]);  //undefined
        console.clear();

        //배열의 반복과 출력
        //1. 전통적인 for 반복문
        //2. for .. in, for..of 반복문
        //3. 배열명.forEach();
        //4. spread Operator(펼침 연산자) ...



        //1. 전통적인 for 반복문
        for(let i=0;i<animals.length;i=i+1){ //i=i+1;   ==   i++;    ==      i+= 1;    세개 다 같은말
            console.log(animals[i])
        }

        //2. for .. in, for..of 반복문
        console.clear();
        // for(let 변수(배열안에 있는 아이템이 순서대로 변수로 호출된다.) of 배열명)
        for(let item of animals){
            console.log(item)  //tiger alligator elephant dog cat sheep hippo
        }

        for(let item in animals){
            console.log(item)  //0 1 2 3 4 5 6    --> index
            console.log(animals[item])  //tiger alligator elephant dog cat sheep hippo
        }



        console.clear();
        //3. 배열명.forEach(function(){});
        //첫번째 매개변수 --> 아이템 각각이 호출된다.
        //두번째 매개변수 --> 아이템 각각의 인덱스가 호출된다.
        //세번째 매개변수 --> 아이템의 원배열이 호출된다.

        animals.forEach(function(item, ind, oriarr){  //변수이름은 상관없음
            // console.log(item)  //tiger alligator elephant dog cat sheep hippo
            // console.log(ind)   //0 1 2 3 4 5 6    --> index
            // console.log(oriarr)   //['tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo']
        })

        animals.forEach(function(ele){
            console.log(ele)   //tiger alligator elephant dog cat sheep hippo
        })

        //Arrow function(=>)
        // animals.forEach((ele)=>{
        //     console.log(ele)
        // })
        // 내용물이 한줄이므로 중괄호 삭제 가능

        // animals.forEach((ele)=>console.log(ele))
        //매개변수가 한개이므로 괄호 생략 가능

        animals.forEach(ele=>console.log(ele))


        //4. spread Operator(펼침 연산자) ...
        console.clear();
        
        console.log(...animals)  //tiger alligator elephant dog cat sheep hippo


        // 삽입과 삭제
        //push(), pop() --> 뒤에서 삽입하고 삭제
        //unshift(), shift() --> 앞에서 삽입하고 삭제  --> 쉬프트는 배열의 정렬에 사용된다.

        let testAr=[1,2,3,4,5,6];

        testAr.push(7);
        console.log(testAr)  //[1,2,3,4,5,6,7]

        testAr.pop(7);   //7은 안적어도 어차피 뒤에 숫자가 삭제된다.
        console.log(testAr) //[1,2,3,4,5,6]
        
        testAr.pop();
        console.log(testAr)  //[1,2,3,4,5]

        testAr.pop();
        console.log(testAr)  //[1,2,3,4]

        //pop();   가장 마지막 아이템이 빠져나감



        testAr.unshift('a');
        console.log(testAr)  //['a', 1, 2, 3, 4]

        testAr.shift();
        console.log(testAr)  //[1, 2, 3, 4]

        testAr.shift();
        console.log(testAr)   //[2, 3, 4]


        //💚 split()메서드
        //기능 --> 문자열을 배열로 리턴 --> 문자열에서 특정한 구분자를 기준으로 잘라내서 새로운 배열로 리턴
        //사용 --> 문자열.split(구분자,limit);
        console.clear();

        let someSt="집에 가고 싶은데 이젠 진짜 너무 졸린데";
        //let splitted=someSt.split(" "); //띄워쓰기 기준으로 나뉘어진다
        //console.log(splitted)   //['집에', '가고', '싶은데', '이젠', '진짜', '너무', '졸린데']
        let splitted=someSt.split(" ",2);
        console.log(splitted)   //['집에', '가고']

        let someSt2="진도, 제주도, 거제도, 독도, 마라도";
        // let splitted2=someSt2.split(', ');
        // console.log(splitted2)    //['진도', '제주도', '거제도', '독도', '마라도']
        
        let splitted2=someSt2.split(', ',4);
        console.log(splitted2)   //['진도', '제주도', '거제도', '독도']
        

        //💛slice() 메서드 --> 비교하여 splice() 메서드
        //slice, splice --> 둘은 비슷하나 차이점이 있다.

        // slice()메서드는 원본 배열을 수정하지 않음. --> 즉, 새로운 배열을 리턴

        // splice() --> 원본 배열을 수정함.
        
        //1) 사용법
        //slice(start)
        //slice(start, end) // end는 지정한 end전까지를 잘라냄.
        console.clear();
        let sliceArr = [ 'tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo' ];

        //배열명.slice(1)// 인덱스[1]포함해서 그 뒤로는 모두 잘라낸다
        let sliceAr1 = sliceArr.slice(1);
        console.log(sliceAr1)   //['alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo']
        console.log(sliceArr)  //원본 보존

        let sliceAr2 = sliceArr.slice(1, 4);  //인덱스 1,2,3
        console.log(sliceAr2)

        const sliceNums = [1,2,3,4,5,6,7,8,9,10];

        const sliceArNum1 = sliceNums.slice(5);
        console.log(sliceArNum1)  // [6, 7, 8, 9, 10]
        console.log(sliceNums)   //원본 보존

        //splice() 메서드
        //배열의 기존 요소를 삭제하거나 교체하고자 할때 --> 새로운 요소를 추가 --> 배열의 값을 변경
        //원본을 수정, 잘라내고(삭제) 이어붙이기 가능.
        console.clear();

        //사용법
        //splice(start,count[=몇개를 잘라낼것인가])
        //splice(start,count,값1,값2) //값1,값2 -> 잘라낸 자리에 대체 할 아이템
            
        //1)
        const oriArr = [1,2,3,4,5,6,7,8,9,10];

        // const splicAr1 = oriArr.splice(5);
        // console.log(splicAr1)   // [6, 7, 8, 9, 10]
        // console.log("원본배열 : " + oriArr)    //원본배열 : 1,2,3,4,5  >>나머지는 잘려나감

        //2)
        // const splicAr2 = oriArr.splice(4,3);
        // console.log(splicAr2) // [5, 6, 7]
        // console.log(oriArr) // [1, 2, 3, 4, 8, 9, 10]

        //3)
        // const splicAr3 = oriArr.splice(3,2,'a','b','c');
        // console.log(splicAr3) // [4,5]
        // console.log(oriArr) // [1, 2, 3, 'a', 'b', 'c', 6, 7, 8, 9, 10]

        //4)
        const oriStrings = ['홍길동','이순신','강감찬','김유신','임꺽정'];

        // const oristring1 = oriStrings.splice(2,2,'세종대왕','을지문덕')
        // console.log(oristring1) //['강감찬','김유신']
        // console.log(oriStrings) //['홍길동','이순신','세종대왕','을지문덕','임꺽정']


        //마이너스 --> 뒤에서부터 n개 자름
        // const oristring2 = oriStrings.splice(-2);  
        // console.log(oristring2)  // ['김유신', '임꺽정']
        // console.log(oriStrings)  // ['홍길동', '이순신', '강감찬']


        //0 --> 새로운 요소 삽입, 삭제하는 요소 없음
        const oristring3 = oriStrings.splice(3,0,'광개토대왕');
        console.log(oristring3) //[]  >>잘라낸것이 없으므로 비어있는 배열이 나타남
        console.log(oriStrings) //['홍길동', '이순신', '강감찬', '광개토대왕', '김유신', '임꺽정']  >>원래 '김유신'이 있어야 할 인덱스3번 자리를 '광개토대왕'이 자리차지함.

        //🧡배열 붙이기 concat() 메서드
        console.clear();


        const myArr1 = [1,2,3,4];
        const myArr2 = [5,6,7,8];
        
        const myArr12 = myArr1.concat(myArr2);
        console.log(myArr12)  //[1, 2, 3, 4, 5, 6, 7, 8]
        console.log(myArr1)  //[1, 2, 3, 4]
        console.log(myArr2)  //[5, 6, 7, 8]

        const myArr21 = myArr2.concat(myArr1);
        console.log(myArr21) //[5, 6, 7, 8, 1, 2, 3, 4]
        console.log(myArr1)  //[1, 2, 3, 4]
        console.log(myArr2)  //[5, 6, 7, 8]

        //문자열
        const str1 = "Hello";
        const str2 = "Javascript";
        console.log(str1.concat(str2)) //HelloJavascript
        console.log(str1.concat(' ',str2)) //Hello Javascript
        console.log(str2.concat(', ',str1)) //Javascript, Hello

        //전개 연산자(spread operator) --> 배열의 각 요소를 개별적인 인수로 전달한다.
        const someList = ['안녕',' ','난',' ', '뽀로로야~','!!'];
        console.log(...someList)  //안녕   난   뽀로로야~ !!
        console.log(''.concat(...someList))  //안녕 난 뽀로로야~!!

        //index 몇번째에 있는지 찾기 --> indexOf() 메서드
        console.clear();

        const greatMan = ['홍길동','이순신','강감찬','김유신','임꺽정'];

        console.log(greatMan.indexOf('강감찬'))  //2
        console.log(greatMan.indexOf('임꺽정'))  //4
        console.log(greatMan.indexOf('임정'))    //-1  --> 없는 값을 indexOf() 메서드로 찾으면 -1이 리턴(★중요)

        console.clear();
        let abcAr1 = "ABCDEFG HIJKLMN";  //띄워쓰기도 문자로 취급한다.

        console.log(abcAr1.indexOf('H'))  //8
        console.log(abcAr1.indexOf('h'))  //-1   //대소문자도 구분한다.

        console.log(abcAr1.lastIndexOf('H'))  //8   //역순으로 검사한다. 결과값은 indexOf와 다르지않다.

        let abcAr2 = "abcdABCD";
        console.log(abcAr2.lastIndexOf('A'));  //4
        //toUpperCase() --> 대문자로 변환
        console.log(abcAr2.toUpperCase().indexOf('A'));  //0  --> 첫번째로 찾은 값을 표시한다
        console.log(abcAr2.toUpperCase().lastIndexOf('A'));   //4


        //indexof옵션 --> indexOf("찾을 특정 값","시작할 위치")
        console.clear();
        const nums = ['k','o','r','e','a','u','s','a','o','r','e'];
        
        console.log(nums.indexOf('a'));  //4
        console.log(nums.indexOf('a',5)); //7   //index번호 5번부터 a를 찾아라
        console.log(nums.indexOf('a',8));  //-1(a가 없기 때문)


        //반복문
        const nums2 = "abcdaasdfasdsasdfaabdasfjasdfja";
        
        const serchNumber = 'asdf';
        let startPosition = 0;
        let lastResult = [];

        while(true){
            let idxRst = nums2.indexOf(serchNumber,startPosition);
            if(idxRst == -1){
                break;
            }
            lastResult.push(idxRst);
            startPosition = idxRst + 1;
        }
        console.log('찾고자하는 인덱스는' + lastResult)
        console.log('출현 빈도수' + lastResult.length)

        //배열에 특정 요소가 포함되어 있는지 없는지 알기 --> 💚includes()

        const testArr = ['korea','usa','japan','canada'];
        console.log(testArr.includes('japan')) //true
        console.log(testArr.includes('maxico')) //false

        //배열내 요소들을 하나로 묶어주기 --> 그때, 문자열(String)타입으로 묶어주기 --> 🧡join()
        console.clear();
        const testArr2 = ['korea','usa','japan','canada'];
        console.log(testArr2.join())//korea,usa,japan,canada //아무 옵션도 넣지않고 호출하면 배열 요소 각각을 콤마(,)로 공백 없이 묶어준다.
        console.log(typeof testArr2.join())  //string
        console.log(testArr2.join('-'))  //구분자로 각각의 요소를 구분하여 하나의 문자열로 이어줌
        console.log(testArr2.join(' '))
        console.log(testArr2.join(', '))
        console.log(testArr2.join('+'))
        console.log(testArr2.join('/'))
        


        //요소가 undefined, null이 있을때 join()메서드를 사용하면?  --> 빈 문자열로 연결
        const testArr3 = ['korea','usa',undefined,'japan',null,'canada'];
        console.log(testArr3.join())  //korea,usa,,japan,,canada

        const testArr4 = [];
        console.log(testArr4.join())   //출력되는 내용없음

        //배열을 거꾸로 출력하는 방법 --> 💙reverse()
        const testArr5 = ['a','b','c','d','e'];
        console.log(testArr5.reverse())   // ['e', 'd', 'c', 'b', 'a']


        //조건에 맞는 첫번째 요소 찾기 --> find() --> 콜백함수 사용.
        //만일 값이 없다면 undefined를 출력한다.

        console.clear();
        const tesrAr6 = [56,34,89,95,100,90];

        //find() vs filter() 비교(차이점)
        //find() 메서드 --> 첫번째 요소의 값을 반환. 더 이상 순회하지 X.
        //filter() 메서드 --> 계속 순회 O --> 조건에 맞는 값을 다 찾아줌.

        // const rst1 = testAr6.find(function(){})  //<<콜백함수
        // const rst1 = testAr6.find(function(ele){
        //     return ele>=80
        // })
        // console.log(rst1)  //89 //오류났늠!!!!!!!!!!!!!


        // const rst1 = testAr6.find((ele)=>{
        //     return ele>=80
        // })

        // const rst1 = testAr6.find(ele=>{
        //     return ele>=80
        // })

        // const rst1 = testAr6.find(ele=>ele>=80); //오류!!!!!!!!!

        // console.log(rst1)  //89


        let testAr7 = [1,2,3,4,5,6,7,8,9,10,3];
        let count = 0;
        const rst2 = testAr7.find(ele=>{
            count++;
            return ele == 3;
        });
        console.log(`해당 메서드의 반복회수는 = ${count}`)  //해당 메서드의 반복회수는 = 3
        console.log(rst2) //3
        console.log(typeof rst2) //number




        const rst3 = testAr7.filter(ele=>{
            count++;
            return ele == 3;
        });
        console.log(`해당 메서드의 반복회수는 = ${count}`) //해당 메서드의 반복회수는 = 14
        console.log(rst3)  //[3,3]
        console.log(typeof rst3)  //object

        
        const cars = [
            {name:'테슬라',price:2500},
            {name:'벤츠',price:3500},
            {name:'테슬라',price:5500},
            {name:'벤츠',price:6600},
            {name:'아우디',price:4500},
        ];

        // const searchvalue = cars.find(function(ele){return ele.price>4000});
        const searchvalue = cars.find(ele=>ele.price>4000);
        console.log(searchvalue)  //{name: '테슬라', price: 5500}


        const searchvalue2 = cars.find(ele=>ele.name == '벤츠');
        console.log(searchvalue2)  //{name: '벤츠', price: 3500}



        //콜백함수
        function serchValue(car){
            return car.name == '테슬라'
        }
        // serchValue(jj)//이게 무슨뜻??

        // let serchValue = function (car){
        //     return car.name == '테슬라'

        // }
        // serchValue(jj)//이게 무슨뜻??

        console.log(cars.find(serchValue))

        
    </script>
</body>
</html>